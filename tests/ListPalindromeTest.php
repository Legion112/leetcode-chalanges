<?php

namespace Tests;

use App\ListNode;
use App\ListPalindrome;
use http\Header;
use PHPUnit\Framework\Attributes\DataProvider;
use PHPUnit\Framework\Attributes\Test;
use PHPUnit\Framework\TestCase;

class ListPalindromeTest extends TestCase
{


    private ListPalindrome $solution;

    protected function setUp(): void
    {
        $this->solution = new ListPalindrome();
        parent::setUp(); // TODO: Change the autogenerated stub
    }

    public static function palindromeHeads():\Generator
    {
        yield [
            self::generateListFromArray([1, 2, 2, 1])
        ];
        yield [
            self::generateListFromArray([1, 2, 1])
        ];
    }

    #[DataProvider('palindromeHeads')]
    #[Test]
    public function trueIsPalindrome(ListNode $head):void
    {
        $list = $this->printList($head);
        self::assertTrue(
            $this->solution->isPalindrome($head),
            sprintf("List: %s\nMust be a palindrome", $list),
        );
    }

    public static function notPalindromeHeads():\Generator
    {
        yield [
            self::generateListFromArray([1, 2, 3])
        ];
        yield [
            self::generateListFromArray([1, 2, 3, 1])
        ];
        yield [
            self::generateListFromArray([1, 2])
        ];
    }

    #[DataProvider('notPalindromeHeads')]
    #[Test]
    public function falseIsPalindrome(ListNode $head):void
    {
        self::assertFalse(
            $this->solution->isPalindrome($head)
        );
    }


    /**
     * @param list<int> $array
     */
    private static function generateListFromArray(array $array):ListNode
    {
        $head =  new ListNode(reset($array));
        $prev = $head;
        while (($nextValue = next($array)) !== false) {
            $next = new ListNode($nextValue);
            $prev->next = $next;
            $prev = $next;
        }
        return $head;
    }

    private function printList(ListNode $head):string
    {
        $values = [$head->val];
        $next = $head;
        while (($next = $next->next) !== null) {
            $values[] = $next->val;
        }
        return '[' . implode(', ', $values) . ']';
    }
}
